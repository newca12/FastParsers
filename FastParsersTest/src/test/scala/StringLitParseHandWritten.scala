/**
 * This object contains a few "hand" written implementations of the double parser
 * for comparison with versions generated by macros and LMS
 */

object StringLitParseHandWritten {

  case class CharArrayStruct(in: Array[Char], start: Int, end: Int) {
    override def toString = in.slice(start, end).mkString
  }

  abstract class JSValue
  case class JSArray(ls: List[JSValue]) extends JSValue
  case class JString(s: CharArrayStruct) extends JSValue

  def isDigit(c: Char) = c >= '0' && c <= '9'

  def parseStringLit1(input: Array[Char], offset: Int): (Option[String], Int) = {
    var tmpOffset = offset

    def isNEOI = tmpOffset < input.length
    def currentInput = input(tmpOffset)
    def advance = { tmpOffset = tmpOffset + 1 }

    while (isNEOI && currentInput == ' ') advance
    val beginPos = tmpOffset

    if (isNEOI && currentInput == '\"') advance else return (None, offset)

    while (isNEOI && currentInput != '\"') {
      if (currentInput == '\\') advance
      advance
    }

    if (isNEOI && currentInput == '\"') advance else return (None, offset)

    (
      Some(input.slice(beginPos + 1, tmpOffset - 1).mkString),
      tmpOffset
    )

  }

  // separating parsing a string literal in a different function
  // creating option for getting the result
  def parseCSVStringLits(input: Array[Char], offset: Int): List[String] = {
    val acc = new scala.collection.mutable.ListBuffer[String]

    var tmpOffset = offset

    def isNEOI = tmpOffset < input.length
    def currentInput = input(tmpOffset)
    def advance = { tmpOffset = tmpOffset + 1 }

    while (isNEOI && currentInput == ' ') advance

    if (isNEOI && currentInput == '[') advance else return Nil

    while (isNEOI && currentInput == ' ') advance

    val firstLit = parseStringLit1(input, tmpOffset)

    firstLit match {
      case (None, _)        ⇒ return Nil
      case (Some(str), off) ⇒ acc += str; tmpOffset = off
    }

    while (isNEOI && currentInput == ' ') advance

    while (isNEOI && currentInput == ',') {
      advance
      parseStringLit1(input, tmpOffset) match {
        case (None, _)        ⇒ return Nil
        case (Some(str), off) ⇒ acc += str; tmpOffset = off
      }
      while (isNEOI && currentInput == ' ') advance
    }

    while (isNEOI && currentInput == ' ') advance
    if (isNEOI && currentInput == ']') advance else return Nil

    acc.toList
  }

  //inlining the parsing of string literal
  // attention: inlining of functions isNEOI, currentInput, advance makes no difference
  def parseCSVStringLits2(input: Array[Char], offset: Int): List[String] = {
    val acc = new scala.collection.mutable.ListBuffer[String]

    var tmpOffset = offset

    def isNEOI = tmpOffset < input.length
    def currentInput = input(tmpOffset)
    def advance = { tmpOffset = tmpOffset + 1 }

    while (isNEOI && currentInput == ' ') advance

    if (isNEOI && currentInput == '[') advance else return Nil

    while (isNEOI && currentInput == ' ') advance

    //parsing the first string literal
    while (isNEOI && currentInput == ' ') advance
    val beginPos = tmpOffset

    if (isNEOI && currentInput == '\"') advance else return Nil

    while (isNEOI && currentInput != '\"') {
      if (currentInput == '\\') advance
      advance
    }

    if (isNEOI && currentInput == '\"') advance else return Nil
    acc += input.slice(beginPos + 1, tmpOffset - 1).mkString

    //end here

    while (isNEOI && currentInput == ' ') advance

    while (isNEOI && currentInput == ',') {
      advance

      //next string literal
      while (isNEOI && currentInput == ' ') advance
      val beginPos = tmpOffset

      if (isNEOI && currentInput == '\"') advance else return Nil

      while (isNEOI && currentInput != '\"') {
        if (currentInput == '\\') advance
        advance
      }

      if (isNEOI && currentInput == '\"') advance else return Nil
      acc += input.slice(beginPos + 1, tmpOffset - 1).mkString

      //end here

      while (isNEOI && currentInput == ' ') advance
    }

    while (isNEOI && currentInput == ' ') advance
    if (isNEOI && currentInput == ']') advance else return Nil

    acc.toList
  }

  //using CharArrayStructs
  def parseCSVStringLits3(input: Array[Char], offset: Int): List[CharArrayStruct] = {
    val acc = new scala.collection.mutable.ListBuffer[CharArrayStruct]

    var tmpOffset = offset

    def isNEOI = tmpOffset < input.length
    def currentInput = input(tmpOffset)
    def advance = { tmpOffset = tmpOffset + 1 }

    while (isNEOI && currentInput == ' ') advance

    if (isNEOI && currentInput == '[') advance else return Nil

    while (isNEOI && currentInput == ' ') advance

    //parsing the first string literal
    while (isNEOI && currentInput == ' ') advance
    val beginPos = tmpOffset

    if (isNEOI && currentInput == '\"') advance else return Nil

    while (isNEOI && currentInput != '\"') {
      if (currentInput == '\\') advance
      advance
    }

    if (isNEOI && currentInput == '\"') advance else return Nil
    acc += CharArrayStruct(input, beginPos + 1, tmpOffset - 1)

    //end here

    while (isNEOI && currentInput == ' ') advance

    while (isNEOI && currentInput == ',') {
      advance

      //next string literal
      while (isNEOI && currentInput == ' ') advance
      val beginPos = tmpOffset

      if (isNEOI && currentInput == '\"') advance else return Nil

      while (isNEOI && currentInput != '\"') {
        if (currentInput == '\\') advance
        advance
      }

      if (isNEOI && currentInput == '\"') advance else return Nil
      acc += CharArrayStruct(input, beginPos + 1, tmpOffset - 1)

      //end here

      while (isNEOI && currentInput == ' ') advance
    }

    while (isNEOI && currentInput == ' ') advance
    if (isNEOI && currentInput == ']') advance else return Nil

    acc.toList
  }

  //an extra boxing around the result of a parse
  def parseCSVStringLits4(input: Array[Char], offset: Int): JSValue = {
    val acc = new scala.collection.mutable.ListBuffer[JSValue]

    var tmpOffset = offset

    def isNEOI = tmpOffset < input.length
    def currentInput = input(tmpOffset)
    def advance = { tmpOffset = tmpOffset + 1 }

    while (isNEOI && currentInput == ' ') advance

    if (isNEOI && currentInput == '[') advance else return JSArray(Nil)

    while (isNEOI && currentInput == ' ') advance

    //parsing the first string literal
    while (isNEOI && currentInput == ' ') advance
    val beginPos = tmpOffset

    if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)

    while (isNEOI && currentInput != '\"') {
      if (currentInput == '\\') advance
      advance
    }

    if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)
    acc += JString(CharArrayStruct(input, beginPos + 1, tmpOffset - 1))

    //end here
    while (isNEOI && currentInput == ' ') advance

    while (isNEOI && currentInput == ',') {
      advance

      //next string literal
      while (isNEOI && currentInput == ' ') advance
      val beginPos = tmpOffset

      if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)

      while (isNEOI && currentInput != '\"') {
        if (currentInput == '\\') advance
        advance
      }

      if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)
      acc += JString(CharArrayStruct(input, beginPos + 1, tmpOffset - 1))

      //end here

      while (isNEOI && currentInput == ' ') advance
    }

    while (isNEOI && currentInput == ' ') advance
    if (isNEOI && currentInput == ']') advance else return JSArray(Nil)

    JSArray(acc.toList)
  }

  //code gen a la LMS for rep1 and stringlit, with extra layer of boxing for results
  // a | b = lift(lift(a) or b)
  // repsep(p,q) = p ~ rep(q ~ p) | success(Nil)
  // stringlit = '\\' ~ anything | not('\"')
  def parseCSVStringLits5(input: Array[Char], offset: Int): JSValue = {

    val parseBackSlash = (i: Int) ⇒ {
      if (i < input.length && input(i) == '\\' && (i + 1) < input.length) Some(i + 2)
      else None
    }

    val backSlashOrAnything = (i: Int) ⇒ {
      parseBackSlash(i) match {
        case None  ⇒ if (i < input.length && input(i) != '\"') Some(i + 1) else None
        case other ⇒ other
      }
    }

    val innerFun1 = (i: Int) ⇒ {
      val acc = new scala.collection.mutable.ListBuffer[JSValue]

      var tmpOffset = i

      def isNEOI = tmpOffset < input.length
      def currentInput = input(tmpOffset)
      def advance = { tmpOffset = tmpOffset + 1 }

      while (isNEOI && currentInput == ' ') advance

      if (isNEOI && currentInput == '[') advance else return JSArray(Nil)

      while (isNEOI && currentInput == ' ') advance

      //parsing the first string literal
      while (isNEOI && currentInput == ' ') advance
      val beginPos = tmpOffset

      if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)

      while (isNEOI && currentInput != '\"') {
        backSlashOrAnything(tmpOffset) match {
          case Some(next) ⇒ tmpOffset = next
          case None       ⇒ ()
        }
      }

      if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)
      acc += JString(CharArrayStruct(input, beginPos + 1, tmpOffset - 1))

      //end here
      while (isNEOI && currentInput == ' ') advance

      while (isNEOI && currentInput == ',') {
        advance

        //next string literal
        while (isNEOI && currentInput == ' ') advance
        val beginPos = tmpOffset

        if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)

        while (isNEOI && currentInput != '\"') {
          backSlashOrAnything(tmpOffset) match {
            case Some(next) ⇒ tmpOffset = next
            case None       ⇒ ()
          }
        }

        if (isNEOI && currentInput == '\"') advance else return JSArray(Nil)
        acc += JString(CharArrayStruct(input, beginPos + 1, tmpOffset - 1))

        //end here

        while (isNEOI && currentInput == ' ') advance
      }

      while (isNEOI && currentInput == ' ') advance
      if (isNEOI && currentInput == ']') advance else return JSArray(Nil)

      JSArray(acc.toList)
    }

    val innerFun2 = (i: Int) ⇒ {
      val tmp = innerFun1(i)
      tmp
    }

    innerFun2(offset)
  }

  def main(args: Array[String]) {
    println("check it out man!")
    println(parseStringLit1("\"go deh natty dread\"".toCharArray, 0))

    val strlits = "[\"higher\", \"natty\", \"jah jah\", \"\'asdf\"]".toCharArray

    println(parseCSVStringLits(strlits, 0))
    println(parseCSVStringLits2(strlits, 0))
    println(parseCSVStringLits4(strlits, 0))
    println(parseCSVStringLits5(strlits, 0))
  }

}